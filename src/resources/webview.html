<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WMF/EMF Viewer</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            color: #333;
        }
        .container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }
        .title {
            font-size: 18px;
            font-weight: 600;
            color: #1976d2;
        }
        .toolbar {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 8px 16px;
            background-color: #1976d2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        button:hover {
            background-color: #1565c0;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:active {
            transform: translateY(0);
        }
        .canvas-section {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            background-color: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 20px;
        }
        canvas {
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 2px;
            max-width: 100%;
            max-height: 100%;
        }
        .canvas-info {
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #666;
        }
        .status-bar {
            margin-top: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 12px;
        }
        .status-item {
            padding: 6px 12px;
            background-color: #f5f5f5;
            border-radius: 12px;
            color: #666;
            font-weight: 500;
        }
        .sidebar {
            width: 350px;
            background-color: white;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 8px rgba(0,0,0,0.05);
        }
        .sidebar-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            background-color: #f9f9f9;
            font-weight: 600;
            font-size: 14px;
            color: #333;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        .records-list {
            flex: 1;
            overflow-y: auto;
        }
        .record-item {
            padding: 10px 20px;
            border-bottom: 1px solid #f0f0f0;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #333;
        }
        .record-item:hover {
            background-color: #f5f5f5;
            padding-left: 24px;
        }
        .record-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
            font-weight: 500;
            border-left: 3px solid #1976d2;
            padding-left: 17px;
        }
        .debug {
            background-color: #2d2d2d;
            color: #e0e0e0;
            padding: 12px;
            margin-top: 10px;
            border-radius: 4px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            white-space: pre-wrap;
            max-height: 120px;
            overflow-y: auto;
            font-size: 12px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 15px 20px 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="header">
                <div class="title">WMF/EMF Viewer</div>
                <div class="toolbar">
                    <button id="exportPngBtn">导出为PNG</button>
                    <button id="exportPdfBtn">导出为PDF</button>
                </div>
            </div>
            <div class="canvas-section">
                <div class="canvas-wrapper">
                    <canvas id="wmfCanvas"></canvas>
                </div>
                <div class="canvas-info">
                    <div class="status-bar">
                        <span id="canvasInfo" class="status-item"></span>
                        <span id="fileTypeInfo" class="status-item"></span>
                        <span id="recordsCountInfo" class="status-item"></span>
                        <span id="fileSizeInfo" class="status-item"></span>
                        <span id="parseTimeInfo" class="status-item"></span>
                    </div>
                </div>
            </div>
            <div id="debug" class="debug"></div>
        </div>
        <div class="sidebar">
            <div class="sidebar-header">指令列表</div>
            <div class="sidebar-content">
                <div class="records-list" id="recordsList"></div>
            </div>
        </div>
    </div>
    <script src="metafileParser.browser.js"></script>
    <script>
        // 显示调试信息
        function showDebug(message) {
            const debugDiv = document.getElementById('debug');
            debugDiv.textContent += message + '\n';
            debugDiv.style.display = 'block';
        }

        // 检查脚本是否加载
        showDebug('Script loaded, checking global objects...');
        showDebug('typeof MetafileParser: ' + typeof MetafileParser);
        showDebug('typeof window.MetafileParser: ' + typeof window.MetafileParser);
        showDebug('typeof WmfDrawer: ' + typeof WmfDrawer);
        showDebug('window keys: ' + Object.keys(window).filter(k => k.includes('Parser') || k.includes('Drawer')).join(', '));

        // 导出为PNG
        function exportToPNG() {
            const canvas = document.getElementById('wmfCanvas');
            try {
                // 创建下载链接
                const link = document.createElement('a');
                link.download = 'metafile-export.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            } catch (error) {
                console.error('Error exporting PNG:', error);
                showDebug('导出PNG时出错: ' + error.message);
            }
        }

        let currentBase64Data = null;

        // 导出为PDF（矢量，使用绘制指令生成）
        function exportToPDF() {
            try {
                if (!currentBase64Data) {
                    throw new Error('没有可用的源数据，无法导出PDF');
                }

                const binaryString = atob(currentBase64Data);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                if (typeof MetafileParser === 'undefined') {
                    throw new Error('MetafileParser is not defined. The browser bundle may not have loaded correctly.');
                }

                const parser = new MetafileParser(bytes);
                const result = parser.parse();
                if (result.error) {
                    throw new Error(result.error);
                }

                const pdfCtx = new PdfContext();
                let drawer;
                if (parser.fileType === 'wmf' || parser.fileType === 'placeable-wmf') {
                    drawer = new WmfDrawer(pdfCtx);
                } else if (parser.fileType === 'emf') {
                    drawer = new EmfDrawer(pdfCtx);
                } else if (parser.fileType === 'emf+') {
                    drawer = new EmfPlusDrawer(pdfCtx);
                } else {
                    throw new Error('Unknown file type: ' + parser.fileType);
                }

                drawer.draw(result);

                const pdfBytes = pdfCtx.buildPdf();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.download = 'metafile-export.pdf';
                link.href = URL.createObjectURL(blob);
                link.click();
                URL.revokeObjectURL(link.href);
            } catch (error) {
                console.error('Error exporting PDF:', error);
                showDebug('导出PDF时出错: ' + error.message);
            }
        }

        function PdfContext() {
            this.canvas = { width: 0, height: 0 };
            this.strokeStyle = '#000000';
            this.fillStyle = '#000000';
            this.lineWidth = 1;
            this.font = '12px Helvetica';
            this.fillRule = 'nonzero';
            this._commands = [];
            this._path = [];
            this._stateStack = [];
            this._currentPoint = null;
        }

        PdfContext.prototype._formatNumber = function (value) {
            const rounded = Math.round(value * 100) / 100;
            return Number.isInteger(rounded) ? String(rounded) : String(rounded);
        };

        PdfContext.prototype._convertY = function (y) {
            return this.canvas.height - y;
        };

        PdfContext.prototype._parseColor = function (style) {
            if (!style) return { r: 0, g: 0, b: 0 };
            if (style.startsWith('#')) {
                const hex = style.slice(1);
                if (hex.length === 3) {
                    const r = parseInt(hex[0] + hex[0], 16);
                    const g = parseInt(hex[1] + hex[1], 16);
                    const b = parseInt(hex[2] + hex[2], 16);
                    return { r, g, b };
                }
                if (hex.length === 6) {
                    const r = parseInt(hex.slice(0, 2), 16);
                    const g = parseInt(hex.slice(2, 4), 16);
                    const b = parseInt(hex.slice(4, 6), 16);
                    return { r, g, b };
                }
            }
            const rgbMatch = style.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
            if (rgbMatch) {
                return {
                    r: parseInt(rgbMatch[1], 10),
                    g: parseInt(rgbMatch[2], 10),
                    b: parseInt(rgbMatch[3], 10)
                };
            }
            return { r: 0, g: 0, b: 0 };
        };

        PdfContext.prototype._emitStrokeStyle = function () {
            const color = this._parseColor(this.strokeStyle);
            const r = this._formatNumber(color.r / 255);
            const g = this._formatNumber(color.g / 255);
            const b = this._formatNumber(color.b / 255);
            this._commands.push(`${r} ${g} ${b} RG`);
            this._commands.push(`${this._formatNumber(this.lineWidth)} w`);
        };

        PdfContext.prototype._emitFillStyle = function () {
            const color = this._parseColor(this.fillStyle);
            const r = this._formatNumber(color.r / 255);
            const g = this._formatNumber(color.g / 255);
            const b = this._formatNumber(color.b / 255);
            this._commands.push(`${r} ${g} ${b} rg`);
        };

        PdfContext.prototype._emitPath = function () {
            if (this._path.length > 0) {
                this._commands.push(this._path.join('\n'));
            }
        };

        PdfContext.prototype._resetPath = function () {
            this._path = [];
            this._currentPoint = null;
        };

        PdfContext.prototype.beginPath = function () {
            this._resetPath();
        };

        PdfContext.prototype.closePath = function () {
            this._path.push('h');
        };

        PdfContext.prototype.moveTo = function (x, y) {
            const px = this._formatNumber(x);
            const py = this._formatNumber(this._convertY(y));
            this._path.push(`${px} ${py} m`);
            this._currentPoint = { x, y };
        };

        PdfContext.prototype.lineTo = function (x, y) {
            const px = this._formatNumber(x);
            const py = this._formatNumber(this._convertY(y));
            this._path.push(`${px} ${py} l`);
            this._currentPoint = { x, y };
        };

        PdfContext.prototype.rect = function (x, y, w, h) {
            const px = this._formatNumber(x);
            const py = this._formatNumber(this._convertY(y + h));
            const pw = this._formatNumber(w);
            const ph = this._formatNumber(h);
            this._path.push(`${px} ${py} ${pw} ${ph} re`);
            this._currentPoint = { x: x + w, y: y + h };
        };

        PdfContext.prototype._bezierTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            const p1x = this._formatNumber(cp1x);
            const p1y = this._formatNumber(this._convertY(cp1y));
            const p2x = this._formatNumber(cp2x);
            const p2y = this._formatNumber(this._convertY(cp2y));
            const px = this._formatNumber(x);
            const py = this._formatNumber(this._convertY(y));
            this._path.push(`${p1x} ${p1y} ${p2x} ${p2y} ${px} ${py} c`);
            this._currentPoint = { x, y };
        };

        PdfContext.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            this._bezierTo(cp1x, cp1y, cp2x, cp2y, x, y);
        };

        PdfContext.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
            if (!this._currentPoint) {
                this.moveTo(x, y);
                return;
            }
            const x0 = this._currentPoint.x;
            const y0 = this._currentPoint.y;
            const cp1x = x0 + (2 / 3) * (cpx - x0);
            const cp1y = y0 + (2 / 3) * (cpy - y0);
            const cp2x = x + (2 / 3) * (cpx - x);
            const cp2y = y + (2 / 3) * (cpy - y);
            this._bezierTo(cp1x, cp1y, cp2x, cp2y, x, y);
        };

        PdfContext.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {
            this._arcToBezier(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
        };

        PdfContext.prototype.ellipse = function (cx, cy, rx, ry, rotation, startAngle, endAngle, anticlockwise) {
            this._arcToBezier(cx, cy, rx, ry, rotation, startAngle, endAngle, anticlockwise);
        };

        PdfContext.prototype._arcToBezier = function (cx, cy, rx, ry, rotation, startAngle, endAngle, anticlockwise) {
            let delta = endAngle - startAngle;
            if (!anticlockwise && delta < 0) {
                delta += Math.PI * 2;
            } else if (anticlockwise && delta > 0) {
                delta -= Math.PI * 2;
            }

            const segments = Math.ceil(Math.abs(delta) / (Math.PI / 2));
            const segmentDelta = delta / segments;
            let angle = startAngle;

            for (let i = 0; i < segments; i++) {
                const angle2 = angle + segmentDelta;
                const k = (4 / 3) * Math.tan((angle2 - angle) / 4);

                const cos1 = Math.cos(angle);
                const sin1 = Math.sin(angle);
                const cos2 = Math.cos(angle2);
                const sin2 = Math.sin(angle2);

                const x1 = cx + rx * cos1;
                const y1 = cy + ry * sin1;
                const x2 = cx + rx * cos2;
                const y2 = cy + ry * sin2;

                const cp1x = x1 - k * rx * sin1;
                const cp1y = y1 + k * ry * cos1;
                const cp2x = x2 + k * rx * sin2;
                const cp2y = y2 - k * ry * cos2;

                const rotated = this._applyRotation(cx, cy, rotation, x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2);

                if (i === 0) {
                    if (!this._currentPoint) {
                        this.moveTo(rotated.x1, rotated.y1);
                    } else {
                        const dx = Math.abs(this._currentPoint.x - rotated.x1);
                        const dy = Math.abs(this._currentPoint.y - rotated.y1);
                        if (dx > 0.01 || dy > 0.01) {
                            this.lineTo(rotated.x1, rotated.y1);
                        }
                    }
                }

                this._bezierTo(rotated.cp1x, rotated.cp1y, rotated.cp2x, rotated.cp2y, rotated.x2, rotated.y2);
                angle = angle2;
            }
        };

        PdfContext.prototype._applyRotation = function (cx, cy, rotation, x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2) {
            if (!rotation) {
                return { x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2 };
            }
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);
            function rotatePoint(x, y) {
                const dx = x - cx;
                const dy = y - cy;
                return {
                    x: cx + dx * cos - dy * sin,
                    y: cy + dx * sin + dy * cos
                };
            }
            const p1 = rotatePoint(x1, y1);
            const p2 = rotatePoint(x2, y2);
            const c1 = rotatePoint(cp1x, cp1y);
            const c2 = rotatePoint(cp2x, cp2y);
            return { x1: p1.x, y1: p1.y, cp1x: c1.x, cp1y: c1.y, cp2x: c2.x, cp2y: c2.y, x2: p2.x, y2: p2.y };
        };

        PdfContext.prototype.fill = function () {
            this._emitPath();
            this._emitFillStyle();
            this._commands.push(this.fillRule === 'evenodd' ? 'f*' : 'f');
            this._resetPath();
        };

        PdfContext.prototype.stroke = function () {
            this._emitPath();
            this._emitStrokeStyle();
            this._commands.push('S');
            this._resetPath();
        };

        PdfContext.prototype.clip = function () {
            this._emitPath();
            this._commands.push(this.fillRule === 'evenodd' ? 'W*' : 'W');
            this._commands.push('n');
            this._resetPath();
        };

        PdfContext.prototype.fillRect = function (x, y, w, h) {
            this.beginPath();
            this.rect(x, y, w, h);
            this.fill();
        };

        PdfContext.prototype.strokeRect = function (x, y, w, h) {
            this.beginPath();
            this.rect(x, y, w, h);
            this.stroke();
        };

        PdfContext.prototype.save = function () {
            this._commands.push('q');
            this._stateStack.push({
                strokeStyle: this.strokeStyle,
                fillStyle: this.fillStyle,
                lineWidth: this.lineWidth,
                font: this.font,
                fillRule: this.fillRule
            });
        };

        PdfContext.prototype.restore = function () {
            this._commands.push('Q');
            const state = this._stateStack.pop();
            if (state) {
                this.strokeStyle = state.strokeStyle;
                this.fillStyle = state.fillStyle;
                this.lineWidth = state.lineWidth;
                this.font = state.font;
                this.fillRule = state.fillRule;
            }
        };

        PdfContext.prototype.measureText = function (text) {
            const size = this._getFontSize();
            return { width: size * 0.6 * text.length };
        };

        PdfContext.prototype._getFontSize = function () {
            const match = this.font.match(/(\d+(?:\.\d+)?)px/i);
            if (match) {
                return parseFloat(match[1]);
            }
            return 12;
        };

        PdfContext.prototype.fillText = function (text, x, y) {
            if (text === undefined || text === null) return;
            const size = this._getFontSize();
            const color = this._parseColor(this.fillStyle);
            const r = this._formatNumber(color.r / 255);
            const g = this._formatNumber(color.g / 255);
            const b = this._formatNumber(color.b / 255);
            const px = this._formatNumber(x);
            const py = this._formatNumber(this._convertY(y));
            const escaped = String(text).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
            this._commands.push(`BT /F1 ${this._formatNumber(size)} Tf ${r} ${g} ${b} rg 1 0 0 1 ${px} ${py} Tm (${escaped}) Tj ET`);
        };

        PdfContext.prototype.buildPdf = function () {
            const width = this.canvas.width || 800;
            const height = this.canvas.height || 600;
            const contentStream = this._commands.join('\n') + '\n';
            return buildPdfFromContent(contentStream, width, height);
        };

        function buildPdfFromContent(contentStream, width, height) {
            const encoder = new TextEncoder();
            const parts = [];
            let position = 0;
            const offsets = [0];

            function pushString(str) {
                const bytes = encoder.encode(str);
                parts.push(bytes);
                position += bytes.length;
            }

            function pushBytes(bytes) {
                parts.push(bytes);
                position += bytes.length;
            }

            function addObject(objNumber, contentBytes) {
                offsets[objNumber] = position;
                pushString(objNumber + ' 0 obj\n');
                pushBytes(contentBytes);
                pushString('\nendobj\n');
            }

            pushString('%PDF-1.4\n');

            addObject(1, encoder.encode('<< /Type /Catalog /Pages 2 0 R >>'));
            addObject(2, encoder.encode('<< /Type /Pages /Kids [3 0 R] /Count 1 >>'));

            const pageDict = `<< /Type /Page /Parent 2 0 R /Resources << /Font << /F1 4 0 R >> >> /MediaBox [0 0 ${width} ${height}] /Contents 5 0 R >>`;
            addObject(3, encoder.encode(pageDict));

            const fontDict = '<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>';
            addObject(4, encoder.encode(fontDict));

            const contentHeader = `<< /Length ${contentStream.length} >>\nstream\n`;
            const contentFooter = '\nendstream';
            addObject(5, encoder.encode(contentHeader + contentStream + contentFooter));

            const xrefPosition = position;
            pushString('xref\n');
            pushString(`0 ${offsets.length}\n`);
            pushString('0000000000 65535 f \n');
            for (let i = 1; i < offsets.length; i++) {
                const offset = offsets[i].toString().padStart(10, '0');
                pushString(`${offset} 00000 n \n`);
            }

            pushString('trailer\n');
            pushString(`<< /Size ${offsets.length} /Root 1 0 R >>\n`);
            pushString('startxref\n');
            pushString(`${xrefPosition}\n`);
            pushString('%%EOF\n');

            const totalLength = parts.reduce((sum, p) => sum + p.length, 0);
            const pdfBytes = new Uint8Array(totalLength);
            let offset = 0;
            for (const part of parts) {
                pdfBytes.set(part, offset);
                offset += part.length;
            }
            return pdfBytes;
        }

        // 格式化参数为友好的字符串
        function formatParams(params) {
            if (typeof params !== 'object' || params === null) {
                return String(params);
            }
            
            // 处理数组
            if (Array.isArray(params)) {
                if (params.length === 0) {
                    return '[]';
                }
                // 检查是否是坐标点数组
                if (params.every(item => typeof item === 'number')) {
                    if (params.length === 2) {
                        return `(${params[0]}, ${params[1]})`;
                    } else if (params.length === 4) {
                        return `(${params[0]}, ${params[1]}) - (${params[2]}, ${params[3]})`;
                    }
                }
                return '[' + params.map(p => formatParams(p)).join(', ') + ']';
            }
            
            // 处理对象
            const keys = Object.keys(params);
            if (keys.length === 0) {
                return '{}';
            }
            
            // 特殊处理常见参数结构
            if (keys.includes('x') && keys.includes('y')) {
                return `(${params.x}, ${params.y})`;
            }
            if (keys.includes('left') && keys.includes('top') && keys.includes('right') && keys.includes('bottom')) {
                return `(${params.left}, ${params.top}) - (${params.right}, ${params.bottom})`;
            }
            
            // 一般对象
            const formatted = keys.map(key => {
                const value = formatParams(params[key]);
                return `${key}: ${value}`;
            });
            
            // 限制显示长度
            const result = '{' + formatted.join(', ') + '}';
            return result.length > 100 ? result.substring(0, 97) + '...' : result;
        }

        // 从原始数据中提取有用信息
        function formatData(data, typeName) {
            if (!data || data.length === 0) {
                return '[无数据]';
            }
            
            // 处理不同类型的指令数据
            switch (typeName) {
                case 'META_MOVETO':
                case 'META_LINETO':
                    if (data.length >= 4) {
                        const x = (data[0] | (data[1] << 8)) << 16 >> 16; // 有符号16位
                        const y = (data[2] | (data[3] << 8)) << 16 >> 16; // 有符号16位
                        return `(${x}, ${y})`;
                    }
                    break;
                case 'META_RECTANGLE':
                case 'META_ELLIPSE':
                    if (data.length >= 8) {
                        const left = (data[0] | (data[1] << 8)) << 16 >> 16;
                        const top = (data[2] | (data[3] << 8)) << 16 >> 16;
                        const right = (data[4] | (data[5] << 8)) << 16 >> 16;
                        const bottom = (data[6] | (data[7] << 8)) << 16 >> 16;
                        return `(${left}, ${top}) - (${right}, ${bottom})`;
                    }
                    break;
                case 'META_SETBKCOLOR':
                case 'META_SETTEXTCOLOR':
                    if (data.length >= 4) {
                        const color = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
                        return `0x${color.toString(16).padStart(8, '0')}`;
                    }
                    break;
                case 'META_SELECTOBJECT':
                    if (data.length >= 2) {
                        const objectIndex = data[0] | (data[1] << 8);
                        return `对象索引: ${objectIndex}`;
                    }
                    break;
                case 'META_CREATEPENINDIRECT':
                case 'META_CREATEBRUSHINDIRECT':
                    return `[复杂参数]`;
                case 'META_TEXTOUT':
                case 'META_EXTTEXTOUT':
                    return `[文本数据]`;
            }
            
            // 对于其他类型，显示通用参数信息
            return `[参数]`;
        }

        // 显示指令列表
        function showRecordsList(records) {
            const recordsList = document.getElementById('recordsList');
            recordsList.innerHTML = '';
            
            records.forEach((record, index) => {
                const recordItem = document.createElement('div');
                recordItem.className = 'record-item';
                
                // 确定记录类型名称
                let typeName = 'Unknown';
                if (record.type) {
                    if (record.typeName) {
                        typeName = record.typeName;
                    } else if (typeof record.type === 'number') {
                        // 对于没有typeName的记录，显示十六进制类型值
                        typeName = '0x' + record.type.toString(16).padStart(4, '0');
                    } else {
                        typeName = record.type;
                    }
                } else if (record.function) {
                    typeName = record.function;
                } else if (record.functionId) {
                    typeName = record.type || '0x' + record.functionId.toString(16).padStart(4, '0');
                }
                
                // 添加额外信息
                let extraInfo = '';
                if (record.flags) {
                    extraInfo += ` (flags: 0x${record.flags.toString(16).padStart(4, '0')})`;
                }
                
                // 添加参数信息
                let paramsInfo = '';
                if (record.params) {
                    try {
                        // 格式化参数为友好的字符串
                        paramsInfo = ' - ' + formatParams(record.params);
                    } catch (e) {
                        // 解析错误时不显示参数
                    }
                } else if (record.data && record.data.length > 0) {
                    try {
                        // 尝试从data中提取有用信息
                        const dataInfo = formatData(record.data, typeName);
                        // 只有在提取到有意义的参数信息时才显示
                        if (dataInfo && dataInfo !== '[参数]') {
                            paramsInfo = ' - ' + dataInfo;
                        }
                    } catch (e) {
                        // 解析错误时不显示参数
                    }
                }
                
                recordItem.textContent = `[${index}] ${typeName}${extraInfo}${paramsInfo}`;
                recordItem.addEventListener('click', () => {
                    // 移除其他选中项
                    document.querySelectorAll('.record-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    // 选中当前项
                    recordItem.classList.add('selected');
                });
                recordsList.appendChild(recordItem);
            });
        }

        // 预览WMF文件
        function previewWMF(base64Data) {
            try {
                currentBase64Data = base64Data;
                // 记录开始时间
                const startTime = performance.now();
                
                // 解码base64数据
                const binaryString = atob(base64Data);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // 计算文件大小
                const fileSizeBytes = bytes.length;
                const fileSizeKB = (fileSizeBytes / 1024).toFixed(2);
                
                showDebug('Binary data length: ' + bytes.length);
                showDebug('File size: ' + fileSizeKB + ' KB');
                showDebug('Creating parser...');

                // 检查 MetafileParser 是否存在
                if (typeof MetafileParser === 'undefined') {
                    throw new Error('MetafileParser is not defined. The browser bundle may not have loaded correctly.');
                }

                // 创建解析器实例
                const parser = new MetafileParser(bytes);
                showDebug('Parser created, starting parsing...');

                // 解析WMF文件
                const result = parser.parse();
                
                // 计算解析时间
                const endTime = performance.now();
                const parseTime = (endTime - startTime).toFixed(2);
                
                showDebug('Parsing completed.');
                showDebug('Parse time: ' + parseTime + ' ms');
                showDebug('File type: ' + parser.fileType);
                showDebug('Records count: ' + result.records.length);

                // 检查是否有错误
                if (result.error) {
                    throw new Error(result.error);
                }

                // 获取Canvas上下文
                const canvas = document.getElementById('wmfCanvas');
                const ctx = canvas.getContext('2d');

                // 根据文件类型选择绘制器
                let drawer;
                if (parser.fileType === 'wmf' || parser.fileType === 'placeable-wmf') {
                    drawer = new WmfDrawer(ctx);
                } else if (parser.fileType === 'emf') {
                    drawer = new EmfDrawer(ctx);
                } else if (parser.fileType === 'emf+') {
                    drawer = new EmfPlusDrawer(ctx);
                } else {
                    throw new Error('Unknown file type: ' + parser.fileType);
                }
                
                showDebug('Drawer created (' + parser.fileType + '), starting drawing...');

                // 绘制WMF文件
                drawer.draw(result);
                
                showDebug('Drawing completed.');
                showDebug('Canvas size: ' + canvas.width + ' x ' + canvas.height);
                
                // 更新Canvas信息
                document.getElementById('canvasInfo').textContent = `尺寸: ${canvas.width} x ${canvas.height}`;
                document.getElementById('fileTypeInfo').textContent = `文件类型: ${parser.fileType}`;
                document.getElementById('recordsCountInfo').textContent = `记录数: ${result.records.length}`;
                document.getElementById('fileSizeInfo').textContent = `文件大小: ${fileSizeKB} KB`;
                document.getElementById('parseTimeInfo').textContent = `解析时间: ${parseTime} ms`;
                
                // 显示指令列表
                showRecordsList(result.records);
                
                // 检查是否有实际内容
                const imageData = ctx.getImageData(0, 0, Math.min(canvas.width, 100), Math.min(canvas.height, 100));
                const data = imageData.data;
                let nonWhitePixels = 0;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i] !== 255 || data[i+1] !== 255 || data[i+2] !== 255) {
                        nonWhitePixels++;
                    }
                }
                showDebug('Non-white pixels in sample area: ' + nonWhitePixels);

            } catch (error) {
                console.error('Error in preview:', error);
                showDebug('Error: ' + error.message + '\nStack: ' + error.stack);
            }
        }

        // 绑定事件
        document.getElementById('exportPngBtn').addEventListener('click', exportToPNG);
        document.getElementById('exportPdfBtn').addEventListener('click', exportToPDF);

        // 执行预览
        try {
            const base64Data = '${wmfBase64}';
            showDebug('Base64 data length: ' + base64Data.length);
            showDebug('Starting WMF preview...');
            previewWMF(base64Data);
        } catch (error) {
            console.error('Error in preview:', error);
            showDebug('Error: ' + error.message + '\nStack: ' + error.stack);
        }
    </script>
</body>
</html>
